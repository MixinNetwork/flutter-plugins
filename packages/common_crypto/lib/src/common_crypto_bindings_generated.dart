// ignore_for_file: always_specify_types
// ignore_for_file: camel_case_types
// ignore_for_file: non_constant_identifier_names

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
import 'dart:ffi' as ffi;

/// Bindings for `src/common_crypto.h`.
///
/// Regenerate bindings with `flutter pub run ffigen --config ffigen.yaml`.
///
class CommonCryptoBindings {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  CommonCryptoBindings(ffi.DynamicLibrary dynamicLibrary)
      : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  CommonCryptoBindings.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  /// !
  /// @function   CCCryptorCreate
  /// @abstract   Create a cryptographic context.
  ///
  /// @param      op          Defines the basic operation: kCCEncrypt or
  /// kCCDecrypt.
  ///
  /// @param      alg         Defines the algorithm.
  ///
  /// @param      options     A word of flags defining options. See discussion
  /// for the CCOptions type.
  ///
  /// @param      key         Raw key material, length keyLength bytes.
  ///
  /// @param      keyLength   Length of key material. Must be appropriate
  /// for the selected operation and algorithm. Some
  /// algorithms  provide for varying key lengths.
  ///
  /// @param      iv          Initialization vector, optional. Used by
  /// block ciphers when Cipher Block Chaining (CBC)
  /// mode is enabled. If present, must be the same
  /// length as the selected algorithm's block size.
  /// If CBC mode is selected (by the absence of the
  /// kCCOptionECBMode bit in the options flags) and no
  /// IV is present, a NULL (all zeroes) IV will be used.
  /// This parameter is ignored if ECB mode is used or
  /// if a stream cipher algorithm is selected. For sound
  /// encryption, always initialize iv with random data.
  ///
  /// @param      cryptorRef  A (required) pointer to the returned CCCryptorRef.
  ///
  /// @result     Possible error returns are kCCParamError and kCCMemoryFailure.
  int CCCryptorCreate(
    int op,
    int alg,
    int options,
    ffi.Pointer<ffi.Void> key,
    int keyLength,
    ffi.Pointer<ffi.Void> iv,
    ffi.Pointer<ffi.Pointer<CCCryptor>> cryptorRef,
  ) {
    return _CCCryptorCreate(
      op,
      alg,
      options,
      key,
      keyLength,
      iv,
      cryptorRef,
    );
  }

  late final _CCCryptorCreatePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Uint32,
              ffi.Uint32,
              ffi.Uint32,
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Pointer<CCCryptor>>)>>('CCCryptorCreate');
  late final _CCCryptorCreate = _CCCryptorCreatePtr.asFunction<
      int Function(int, int, int, ffi.Pointer<ffi.Void>, int,
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Pointer<CCCryptor>>)>();

  /// !
  /// @function   CCCryptorCreateFromData
  /// @abstract   Create a cryptographic context using caller-supplied memory.
  ///
  /// @param      op          Defines the basic operation: kCCEncrypt or
  /// kCCDecrypt.
  ///
  /// @param      alg         Defines the algorithm.
  ///
  /// @param      options     A word of flags defining options. See discussion
  /// for the CCOptions type.
  ///
  /// @param      key         Raw key material, length keyLength bytes.
  ///
  /// @param      keyLength   Length of key material. Must be appropriate
  /// for the selected operation and algorithm. Some
  /// algorithms  provide for varying key lengths.
  ///
  /// @param      iv          Initialization vector, optional. Used by
  /// block ciphers when Cipher Block Chaining (CBC)
  /// mode is enabled. If present, must be the same
  /// length as the selected algorithm's block size.
  /// If CBC mode is selected (by the absence of the
  /// kCCOptionECBMode bit in the options flags) and no
  /// IV is present, a NULL (all zeroes) IV will be used.
  /// This parameter is ignored if ECB mode is used or
  /// if a stream cipher algorithm is selected. For sound
  /// encryption, always initialize iv with random data.
  ///
  /// @param      data        A pointer to caller-supplied memory from which the
  /// CCCryptorRef will be created.
  ///
  /// @param      dataLength  The size of the caller-supplied memory in bytes.
  ///
  /// @param      cryptorRef  A (required) pointer to the returned CCCryptorRef.
  ///
  /// @param      dataUsed    Optional. If present, the actual number of bytes of
  /// the caller-supplied memory which was consumed by
  /// creation of the CCCryptorRef is returned here. Also,
  /// if the supplied memory is of insufficent size to create
  /// a CCCryptorRef, kCCBufferTooSmall is returned, and
  /// the minimum required buffer size is returned via this
  /// parameter if present.
  ///
  /// @result     Possible error returns are kCCParamError and kCCBufferTooSmall.
  ///
  /// @discussion The CCCryptorRef created by this function must be disposed of
  /// via CCCRyptorRelease which clears sensitive data and deallocates memory
  /// when the caller is finished using the CCCryptorRef.
  int CCCryptorCreateFromData(
    int op,
    int alg,
    int options,
    ffi.Pointer<ffi.Void> key,
    int keyLength,
    ffi.Pointer<ffi.Void> iv,
    ffi.Pointer<ffi.Void> data,
    int dataLength,
    ffi.Pointer<ffi.Pointer<CCCryptor>> cryptorRef,
    ffi.Pointer<ffi.Size> dataUsed,
  ) {
    return _CCCryptorCreateFromData(
      op,
      alg,
      options,
      key,
      keyLength,
      iv,
      data,
      dataLength,
      cryptorRef,
      dataUsed,
    );
  }

  late final _CCCryptorCreateFromDataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Uint32,
              ffi.Uint32,
              ffi.Uint32,
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              ffi.Pointer<ffi.Pointer<CCCryptor>>,
              ffi.Pointer<ffi.Size>)>>('CCCryptorCreateFromData');
  late final _CCCryptorCreateFromData = _CCCryptorCreateFromDataPtr.asFunction<
      int Function(
          int,
          int,
          int,
          ffi.Pointer<ffi.Void>,
          int,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<ffi.Void>,
          int,
          ffi.Pointer<ffi.Pointer<CCCryptor>>,
          ffi.Pointer<ffi.Size>)>();

  /// !
  /// @function   CCCryptorRelease
  /// @abstract   Free a context created by CCCryptorCreate or
  /// CCCryptorCreateFromData().
  ///
  /// @param      cryptorRef  The CCCryptorRef to release.
  ///
  /// @result     The only possible error return is kCCParamError resulting
  /// from passing in a null CCCryptorRef.
  int CCCryptorRelease(
    ffi.Pointer<CCCryptor> cryptorRef,
  ) {
    return _CCCryptorRelease(
      cryptorRef,
    );
  }

  late final _CCCryptorReleasePtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<CCCryptor>)>>(
          'CCCryptorRelease');
  late final _CCCryptorRelease =
      _CCCryptorReleasePtr.asFunction<int Function(ffi.Pointer<CCCryptor>)>();

  /// !
  /// @function   CCCryptorUpdate
  /// @abstract   Process (encrypt, decrypt) some data. The result, if any,
  /// is written to a caller-provided buffer.
  ///
  /// @param      cryptorRef      A CCCryptorRef created via CCCryptorCreate() or
  /// CCCryptorCreateFromData().
  /// @param      dataIn          Data to process, length dataInLength bytes.
  /// @param      dataInLength    Length of data to process.
  /// @param      dataOut         Result is written here. Allocated by caller.
  /// Encryption and decryption can be performed
  /// "in-place", with the same buffer used for
  /// input and output. The in-place operation is not
  /// suported for ciphers modes that work with blocks
  /// of data such as CBC and ECB.
  ///
  /// @param      dataOutAvailable The size of the dataOut buffer in bytes.
  /// @param      dataOutMoved    On successful return, the number of bytes
  /// written to dataOut.
  ///
  /// @result     kCCBufferTooSmall indicates insufficent space in the dataOut
  /// buffer. The caller can use
  /// CCCryptorGetOutputLength() to determine the
  /// required output buffer size in this case. The
  /// operation can be retried; no state is lost
  /// when this is returned.
  ///
  /// @discussion This routine can be called multiple times. The caller does
  /// not need to align input data lengths to block sizes; input is
  /// bufferred as necessary for block ciphers.
  ///
  /// When performing symmetric encryption with block ciphers,
  /// and padding is enabled via kCCOptionPKCS7Padding, the total
  /// number of bytes provided by all the calls to this function
  /// when encrypting can be arbitrary (i.e., the total number
  /// of bytes does not have to be block aligned). However if
  /// padding is disabled, or when decrypting, the total number
  /// of bytes does have to be aligned to the block size; otherwise
  /// CCCryptFinal() will return kCCAlignmentError.
  ///
  /// A general rule for the size of the output buffer which must be
  /// provided by the caller is that for block ciphers, the output
  /// length is never larger than the input length plus the block size.
  /// For stream ciphers, the output length is always exactly the same
  /// as the input length. See the discussion for
  /// CCCryptorGetOutputLength() for more information on this topic.
  ///
  /// Generally, when all data has been processed, call
  /// CCCryptorFinal().
  ///
  /// In the following cases, the CCCryptorFinal() is superfluous as
  /// it will not yield any data nor return an error:
  /// 1. Encrypting or decrypting with a block cipher with padding
  /// disabled, when the total amount of data provided to
  /// CCCryptorUpdate() is an integral multiple of the block size.
  /// 2. Encrypting or decrypting with a stream cipher.
  int CCCryptorUpdate(
    ffi.Pointer<CCCryptor> cryptorRef,
    ffi.Pointer<ffi.Void> dataIn,
    int dataInLength,
    ffi.Pointer<ffi.Void> dataOut,
    int dataOutAvailable,
    ffi.Pointer<ffi.Size> dataOutMoved,
  ) {
    return _CCCryptorUpdate(
      cryptorRef,
      dataIn,
      dataInLength,
      dataOut,
      dataOutAvailable,
      dataOutMoved,
    );
  }

  late final _CCCryptorUpdatePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<CCCryptor>,
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              ffi.Pointer<ffi.Size>)>>('CCCryptorUpdate');
  late final _CCCryptorUpdate = _CCCryptorUpdatePtr.asFunction<
      int Function(ffi.Pointer<CCCryptor>, ffi.Pointer<ffi.Void>, int,
          ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Size>)>();

  /// !
  /// @function   CCCryptorFinal
  /// @abstract   Finish an encrypt or decrypt operation, and obtain the (possible)
  /// final data output.
  ///
  /// @param      cryptorRef      A CCCryptorRef created via CCCryptorCreate() or
  /// CCCryptorCreateFromData().
  /// @param      dataOut         Result is written here. Allocated by caller.
  /// @param      dataOutAvailable The size of the dataOut buffer in bytes.
  /// @param      dataOutMoved    On successful return, the number of bytes
  /// written to dataOut.
  ///
  /// @result     kCCBufferTooSmall indicates insufficent space in the dataOut
  /// buffer. The caller can use
  /// CCCryptorGetOutputLength() to determine the
  /// required output buffer size in this case. The
  /// operation can be retried; no state is lost
  /// when this is returned.
  /// kCCAlignmentError When decrypting, or when encrypting with a
  /// block cipher with padding disabled,
  /// kCCAlignmentError will be returned if the total
  /// number of bytes provided to CCCryptUpdate() is
  /// not an integral multiple of the current
  /// algorithm's block size.
  /// kCCDecodeError  Indicates garbled ciphertext or the
  /// wrong key during decryption. This can only
  /// be returned while decrypting with padding
  /// enabled.
  ///
  /// @discussion Except when kCCBufferTooSmall is returned, the CCCryptorRef
  /// can no longer be used for subsequent operations unless
  /// CCCryptorReset() is called on it.
  ///
  /// It is not necessary to call CCCryptorFinal() when performing
  /// symmetric encryption or decryption if padding is disabled, or
  /// when using a stream cipher.
  ///
  /// It is not necessary to call CCCryptorFinal() prior to
  /// CCCryptorRelease() when aborting an operation.
  int CCCryptorFinal(
    ffi.Pointer<CCCryptor> cryptorRef,
    ffi.Pointer<ffi.Void> dataOut,
    int dataOutAvailable,
    ffi.Pointer<ffi.Size> dataOutMoved,
  ) {
    return _CCCryptorFinal(
      cryptorRef,
      dataOut,
      dataOutAvailable,
      dataOutMoved,
    );
  }

  late final _CCCryptorFinalPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<CCCryptor>, ffi.Pointer<ffi.Void>,
              ffi.Size, ffi.Pointer<ffi.Size>)>>('CCCryptorFinal');
  late final _CCCryptorFinal = _CCCryptorFinalPtr.asFunction<
      int Function(ffi.Pointer<CCCryptor>, ffi.Pointer<ffi.Void>, int,
          ffi.Pointer<ffi.Size>)>();

  /// !
  /// @function   CCCryptorGetOutputLength
  /// @abstract   Determine output buffer size required to process a given input
  /// size.
  ///
  /// @param      cryptorRef  A CCCryptorRef created via CCCryptorCreate() or
  /// CCCryptorCreateFromData().
  /// @param      inputLength The length of data which will be provided to
  /// CCCryptorUpdate().
  /// @param      final       If false, the returned value will indicate the
  /// output buffer space needed when 'inputLength'
  /// bytes are provided to CCCryptorUpdate(). When
  /// 'final' is true, the returned value will indicate
  /// the total combined buffer space needed when
  /// 'inputLength' bytes are provided to
  /// CCCryptorUpdate() and then CCCryptorFinal() is
  /// called.
  ///
  /// @result The maximum buffer space need to perform CCCryptorUpdate() and
  /// optionally CCCryptorFinal().
  ///
  /// @discussion Some general rules apply that allow clients of this module to
  /// know a priori how much output buffer space will be required
  /// in a given situation. For stream ciphers, the output size is
  /// always equal to the input size, and CCCryptorFinal() never
  /// produces any data. For block ciphers, the output size will
  /// always be less than or equal to the input size plus the size
  /// of one block. For block ciphers, if the input size provided
  /// to each call to CCCryptorUpdate() is is an integral multiple
  /// of the block size, then the output size for each call to
  /// CCCryptorUpdate() is less than or equal to the input size
  /// for that call to CCCryptorUpdate(). CCCryptorFinal() only
  /// produces output when using a block cipher with padding enabled.
  int CCCryptorGetOutputLength(
    ffi.Pointer<CCCryptor> cryptorRef,
    int inputLength,
    bool final1,
  ) {
    return _CCCryptorGetOutputLength(
      cryptorRef,
      inputLength,
      final1,
    );
  }

  late final _CCCryptorGetOutputLengthPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<CCCryptor>, ffi.Size,
              ffi.Bool)>>('CCCryptorGetOutputLength');
  late final _CCCryptorGetOutputLength = _CCCryptorGetOutputLengthPtr
      .asFunction<int Function(ffi.Pointer<CCCryptor>, int, bool)>();

  /// !
  /// @function   CCCryptorReset
  /// @abstract   Reinitializes an existing CCCryptorRef with a (possibly)
  /// new initialization vector. The CCCryptorRef's key is
  /// unchanged. Use only for CBC and CTR modes.
  ///
  /// @param      cryptorRef  A CCCryptorRef created via CCCryptorCreate() or
  /// CCCryptorCreateFromData().
  /// @param      iv          Optional initialization vector; if present, must
  /// be the same size as the current algorithm's block
  /// size. For sound encryption, always initialize iv with
  /// random data.
  ///
  /// @result     The only possible errors are kCCParamError and
  /// kCCUnimplemented. On macOS 10.13, iOS 11, watchOS 4 and tvOS 11 returns kCCUnimplemented
  /// for modes other than CBC. On prior SDKs, returns kCCSuccess to preserve compatibility
  ///
  /// @discussion This can be called on a CCCryptorRef with data pending (i.e.
  /// in a padded mode operation before CCCryptFinal is called);
  /// however any pending data will be lost in that case.
  int CCCryptorReset(
    ffi.Pointer<CCCryptor> cryptorRef,
    ffi.Pointer<ffi.Void> iv,
  ) {
    return _CCCryptorReset(
      cryptorRef,
      iv,
    );
  }

  late final _CCCryptorResetPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<CCCryptor>,
              ffi.Pointer<ffi.Void>)>>('CCCryptorReset');
  late final _CCCryptorReset = _CCCryptorResetPtr.asFunction<
      int Function(ffi.Pointer<CCCryptor>, ffi.Pointer<ffi.Void>)>();

  /// !
  /// @function   CCCrypt
  /// @abstract   Stateless, one-shot encrypt or decrypt operation.
  /// This basically performs a sequence of CCCrytorCreate(),
  /// CCCryptorUpdate(), CCCryptorFinal(), and CCCryptorRelease().
  ///
  /// @param      alg             Defines the encryption algorithm.
  ///
  ///
  /// @param      op              Defines the basic operation: kCCEncrypt or
  /// kCCDecrypt.
  ///
  /// @param      options         A word of flags defining options. See discussion
  /// for the CCOptions type.
  ///
  /// @param      key             Raw key material, length keyLength bytes.
  ///
  /// @param      keyLength       Length of key material. Must be appropriate
  /// for the select algorithm. Some algorithms may
  /// provide for varying key lengths.
  ///
  /// @param      iv              Initialization vector, optional. Used for
  /// Cipher Block Chaining (CBC) mode. If present,
  /// must be the same length as the selected
  /// algorithm's block size. If CBC mode is
  /// selected (by the absence of any mode bits in
  /// the options flags) and no IV is present, a
  /// NULL (all zeroes) IV will be used. This is
  /// ignored if ECB mode is used or if a stream
  /// cipher algorithm is selected. For sound encryption,
  /// always initialize IV with random data.
  ///
  /// @param      dataIn          Data to encrypt or decrypt, length dataInLength
  /// bytes.
  ///
  /// @param      dataInLength    Length of data to encrypt or decrypt.
  ///
  /// @param      dataOut         Result is written here. Allocated by caller.
  /// Encryption and decryption can be performed
  /// "in-place", with the same buffer used for
  /// input and output.
  ///
  /// @param      dataOutAvailable The size of the dataOut buffer in bytes.
  ///
  /// @param      dataOutMoved    On successful return, the number of bytes
  /// written to dataOut. If kCCBufferTooSmall is
  /// returned as a result of insufficient buffer
  /// space being provided, the required buffer space
  /// is returned here.
  ///
  /// @result     kCCBufferTooSmall indicates insufficent space in the dataOut
  /// buffer. In this case, the *dataOutMoved
  /// parameter will indicate the size of the buffer
  /// needed to complete the operation. The
  /// operation can be retried with minimal runtime
  /// penalty.
  /// kCCAlignmentError indicates that dataInLength was not properly
  /// aligned. This can only be returned for block
  /// ciphers, and then only when decrypting or when
  /// encrypting with block with padding disabled.
  /// kCCDecodeError  Indicates improperly formatted ciphertext or
  /// a "wrong key" error; occurs only during decrypt
  /// operations.
  int CCCrypt(
    int op,
    int alg,
    int options,
    ffi.Pointer<ffi.Void> key,
    int keyLength,
    ffi.Pointer<ffi.Void> iv,
    ffi.Pointer<ffi.Void> dataIn,
    int dataInLength,
    ffi.Pointer<ffi.Void> dataOut,
    int dataOutAvailable,
    ffi.Pointer<ffi.Size> dataOutMoved,
  ) {
    return _CCCrypt(
      op,
      alg,
      options,
      key,
      keyLength,
      iv,
      dataIn,
      dataInLength,
      dataOut,
      dataOutAvailable,
      dataOutMoved,
    );
  }

  late final _CCCryptPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Uint32,
              ffi.Uint32,
              ffi.Uint32,
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              ffi.Pointer<ffi.Size>)>>('CCCrypt');
  late final _CCCrypt = _CCCryptPtr.asFunction<
      int Function(
          int,
          int,
          int,
          ffi.Pointer<ffi.Void>,
          int,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<ffi.Void>,
          int,
          ffi.Pointer<ffi.Void>,
          int,
          ffi.Pointer<ffi.Size>)>();

  /// !
  /// @function   CCCryptorCreateWithMode
  /// @abstract   Create a cryptographic context.
  ///
  /// @param      op         Defines the basic operation: kCCEncrypt or
  /// kCCDecrypt.
  ///
  /// @param     mode		Specifies the cipher mode to use for operations.
  ///
  /// @param      alg        Defines the algorithm.
  ///
  /// @param		padding		Specifies the padding to use.
  ///
  /// @param      iv         Initialization vector, optional. Used by
  /// block ciphers with the following modes:
  ///
  /// Cipher Block Chaining (CBC)
  /// Cipher Feedback (CFB and CFB8)
  /// Output Feedback (OFB)
  /// Counter (CTR)
  ///
  /// If present, must be the same length as the selected
  /// algorithm's block size.  If no IV is present, a NULL
  /// (all zeroes) IV will be used. For sound encryption,
  /// always initialize iv with random data.
  ///
  /// This parameter is ignored if ECB mode is used or
  /// if a stream cipher algorithm is selected.
  ///
  /// @param      key         Raw key material, length keyLength bytes.
  ///
  /// @param      keyLength   Length of key material. Must be appropriate
  /// for the selected operation and algorithm. Some
  /// algorithms  provide for varying key lengths.
  ///
  /// @param      tweak      Raw key material, length keyLength bytes. Used for the
  /// tweak key in XEX-based Tweaked CodeBook (XTS) mode.
  ///
  /// @param      tweakLength   Length of tweak key material. Must be appropriate
  /// for the selected operation and algorithm. Some
  /// algorithms  provide for varying key lengths.  For XTS
  /// this is the same length as the encryption key.
  ///
  /// @param		numRounds	The number of rounds of the cipher to use.  0 uses the default.
  ///
  /// @param      options    A word of flags defining options. See discussion
  /// for the CCModeOptions type.
  ///
  /// @param      cryptorRef  A (required) pointer to the returned CCCryptorRef.
  ///
  /// @result     Possible error returns are kCCParamError and kCCMemoryFailure.
  int CCCryptorCreateWithMode(
    int op,
    int mode,
    int alg,
    int padding,
    ffi.Pointer<ffi.Void> iv,
    ffi.Pointer<ffi.Void> key,
    int keyLength,
    ffi.Pointer<ffi.Void> tweak,
    int tweakLength,
    int numRounds,
    int options,
    ffi.Pointer<ffi.Pointer<CCCryptor>> cryptorRef,
  ) {
    return _CCCryptorCreateWithMode(
      op,
      mode,
      alg,
      padding,
      iv,
      key,
      keyLength,
      tweak,
      tweakLength,
      numRounds,
      options,
      cryptorRef,
    );
  }

  late final _CCCryptorCreateWithModePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Uint32,
              ffi.Uint32,
              ffi.Uint32,
              ffi.Uint32,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              ffi.Int,
              ffi.Uint32,
              ffi.Pointer<ffi.Pointer<CCCryptor>>)>>('CCCryptorCreateWithMode');
  late final _CCCryptorCreateWithMode = _CCCryptorCreateWithModePtr.asFunction<
      int Function(
          int,
          int,
          int,
          int,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<ffi.Void>,
          int,
          ffi.Pointer<ffi.Void>,
          int,
          int,
          int,
          ffi.Pointer<ffi.Pointer<CCCryptor>>)>();

  int CC_MD2_Init(
    ffi.Pointer<CC_MD2state_st> c,
  ) {
    return _CC_MD2_Init(
      c,
    );
  }

  late final _CC_MD2_InitPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<CC_MD2state_st>)>>(
      'CC_MD2_Init');
  late final _CC_MD2_Init =
      _CC_MD2_InitPtr.asFunction<int Function(ffi.Pointer<CC_MD2state_st>)>();

  int CC_MD2_Update(
    ffi.Pointer<CC_MD2state_st> c,
    ffi.Pointer<ffi.Void> data,
    int len,
  ) {
    return _CC_MD2_Update(
      c,
      data,
      len,
    );
  }

  late final _CC_MD2_UpdatePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<CC_MD2state_st>, ffi.Pointer<ffi.Void>,
              ffi.Uint32)>>('CC_MD2_Update');
  late final _CC_MD2_Update = _CC_MD2_UpdatePtr.asFunction<
      int Function(ffi.Pointer<CC_MD2state_st>, ffi.Pointer<ffi.Void>, int)>();

  int CC_MD2_Final(
    ffi.Pointer<ffi.UnsignedChar> md,
    ffi.Pointer<CC_MD2state_st> c,
  ) {
    return _CC_MD2_Final(
      md,
      c,
    );
  }

  late final _CC_MD2_FinalPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.UnsignedChar>,
              ffi.Pointer<CC_MD2state_st>)>>('CC_MD2_Final');
  late final _CC_MD2_Final = _CC_MD2_FinalPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.UnsignedChar>, ffi.Pointer<CC_MD2state_st>)>();

  ffi.Pointer<ffi.UnsignedChar> CC_MD2(
    ffi.Pointer<ffi.Void> data,
    int len,
    ffi.Pointer<ffi.UnsignedChar> md,
  ) {
    return _CC_MD2(
      data,
      len,
      md,
    );
  }

  late final _CC_MD2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.UnsignedChar> Function(ffi.Pointer<ffi.Void>,
              ffi.Uint32, ffi.Pointer<ffi.UnsignedChar>)>>('CC_MD2');
  late final _CC_MD2 = _CC_MD2Ptr.asFunction<
      ffi.Pointer<ffi.UnsignedChar> Function(
          ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.UnsignedChar>)>();

  int CC_MD4_Init(
    ffi.Pointer<CC_MD4state_st> c,
  ) {
    return _CC_MD4_Init(
      c,
    );
  }

  late final _CC_MD4_InitPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<CC_MD4state_st>)>>(
      'CC_MD4_Init');
  late final _CC_MD4_Init =
      _CC_MD4_InitPtr.asFunction<int Function(ffi.Pointer<CC_MD4state_st>)>();

  int CC_MD4_Update(
    ffi.Pointer<CC_MD4state_st> c,
    ffi.Pointer<ffi.Void> data,
    int len,
  ) {
    return _CC_MD4_Update(
      c,
      data,
      len,
    );
  }

  late final _CC_MD4_UpdatePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<CC_MD4state_st>, ffi.Pointer<ffi.Void>,
              ffi.Uint32)>>('CC_MD4_Update');
  late final _CC_MD4_Update = _CC_MD4_UpdatePtr.asFunction<
      int Function(ffi.Pointer<CC_MD4state_st>, ffi.Pointer<ffi.Void>, int)>();

  int CC_MD4_Final(
    ffi.Pointer<ffi.UnsignedChar> md,
    ffi.Pointer<CC_MD4state_st> c,
  ) {
    return _CC_MD4_Final(
      md,
      c,
    );
  }

  late final _CC_MD4_FinalPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.UnsignedChar>,
              ffi.Pointer<CC_MD4state_st>)>>('CC_MD4_Final');
  late final _CC_MD4_Final = _CC_MD4_FinalPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.UnsignedChar>, ffi.Pointer<CC_MD4state_st>)>();

  ffi.Pointer<ffi.UnsignedChar> CC_MD4(
    ffi.Pointer<ffi.Void> data,
    int len,
    ffi.Pointer<ffi.UnsignedChar> md,
  ) {
    return _CC_MD4(
      data,
      len,
      md,
    );
  }

  late final _CC_MD4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.UnsignedChar> Function(ffi.Pointer<ffi.Void>,
              ffi.Uint32, ffi.Pointer<ffi.UnsignedChar>)>>('CC_MD4');
  late final _CC_MD4 = _CC_MD4Ptr.asFunction<
      ffi.Pointer<ffi.UnsignedChar> Function(
          ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.UnsignedChar>)>();

  int CC_MD5_Init(
    ffi.Pointer<CC_MD5state_st> c,
  ) {
    return _CC_MD5_Init(
      c,
    );
  }

  late final _CC_MD5_InitPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<CC_MD5state_st>)>>(
      'CC_MD5_Init');
  late final _CC_MD5_Init =
      _CC_MD5_InitPtr.asFunction<int Function(ffi.Pointer<CC_MD5state_st>)>();

  int CC_MD5_Update(
    ffi.Pointer<CC_MD5state_st> c,
    ffi.Pointer<ffi.Void> data,
    int len,
  ) {
    return _CC_MD5_Update(
      c,
      data,
      len,
    );
  }

  late final _CC_MD5_UpdatePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<CC_MD5state_st>, ffi.Pointer<ffi.Void>,
              ffi.Uint32)>>('CC_MD5_Update');
  late final _CC_MD5_Update = _CC_MD5_UpdatePtr.asFunction<
      int Function(ffi.Pointer<CC_MD5state_st>, ffi.Pointer<ffi.Void>, int)>();

  int CC_MD5_Final(
    ffi.Pointer<ffi.UnsignedChar> md,
    ffi.Pointer<CC_MD5state_st> c,
  ) {
    return _CC_MD5_Final(
      md,
      c,
    );
  }

  late final _CC_MD5_FinalPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.UnsignedChar>,
              ffi.Pointer<CC_MD5state_st>)>>('CC_MD5_Final');
  late final _CC_MD5_Final = _CC_MD5_FinalPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.UnsignedChar>, ffi.Pointer<CC_MD5state_st>)>();

  ffi.Pointer<ffi.UnsignedChar> CC_MD5(
    ffi.Pointer<ffi.Void> data,
    int len,
    ffi.Pointer<ffi.UnsignedChar> md,
  ) {
    return _CC_MD5(
      data,
      len,
      md,
    );
  }

  late final _CC_MD5Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.UnsignedChar> Function(ffi.Pointer<ffi.Void>,
              ffi.Uint32, ffi.Pointer<ffi.UnsignedChar>)>>('CC_MD5');
  late final _CC_MD5 = _CC_MD5Ptr.asFunction<
      ffi.Pointer<ffi.UnsignedChar> Function(
          ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.UnsignedChar>)>();

  int CC_SHA1_Init(
    ffi.Pointer<CC_SHA1state_st> c,
  ) {
    return _CC_SHA1_Init(
      c,
    );
  }

  late final _CC_SHA1_InitPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<CC_SHA1state_st>)>>(
      'CC_SHA1_Init');
  late final _CC_SHA1_Init =
      _CC_SHA1_InitPtr.asFunction<int Function(ffi.Pointer<CC_SHA1state_st>)>();

  int CC_SHA1_Update(
    ffi.Pointer<CC_SHA1state_st> c,
    ffi.Pointer<ffi.Void> data,
    int len,
  ) {
    return _CC_SHA1_Update(
      c,
      data,
      len,
    );
  }

  late final _CC_SHA1_UpdatePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<CC_SHA1state_st>, ffi.Pointer<ffi.Void>,
              ffi.Uint32)>>('CC_SHA1_Update');
  late final _CC_SHA1_Update = _CC_SHA1_UpdatePtr.asFunction<
      int Function(ffi.Pointer<CC_SHA1state_st>, ffi.Pointer<ffi.Void>, int)>();

  int CC_SHA1_Final(
    ffi.Pointer<ffi.UnsignedChar> md,
    ffi.Pointer<CC_SHA1state_st> c,
  ) {
    return _CC_SHA1_Final(
      md,
      c,
    );
  }

  late final _CC_SHA1_FinalPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.UnsignedChar>,
              ffi.Pointer<CC_SHA1state_st>)>>('CC_SHA1_Final');
  late final _CC_SHA1_Final = _CC_SHA1_FinalPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.UnsignedChar>, ffi.Pointer<CC_SHA1state_st>)>();

  ffi.Pointer<ffi.UnsignedChar> CC_SHA1(
    ffi.Pointer<ffi.Void> data,
    int len,
    ffi.Pointer<ffi.UnsignedChar> md,
  ) {
    return _CC_SHA1(
      data,
      len,
      md,
    );
  }

  late final _CC_SHA1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.UnsignedChar> Function(ffi.Pointer<ffi.Void>,
              ffi.Uint32, ffi.Pointer<ffi.UnsignedChar>)>>('CC_SHA1');
  late final _CC_SHA1 = _CC_SHA1Ptr.asFunction<
      ffi.Pointer<ffi.UnsignedChar> Function(
          ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.UnsignedChar>)>();

  int CC_SHA224_Init(
    ffi.Pointer<CC_SHA256state_st> c,
  ) {
    return _CC_SHA224_Init(
      c,
    );
  }

  late final _CC_SHA224_InitPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<CC_SHA256state_st>)>>(
      'CC_SHA224_Init');
  late final _CC_SHA224_Init = _CC_SHA224_InitPtr.asFunction<
      int Function(ffi.Pointer<CC_SHA256state_st>)>();

  int CC_SHA224_Update(
    ffi.Pointer<CC_SHA256state_st> c,
    ffi.Pointer<ffi.Void> data,
    int len,
  ) {
    return _CC_SHA224_Update(
      c,
      data,
      len,
    );
  }

  late final _CC_SHA224_UpdatePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<CC_SHA256state_st>,
              ffi.Pointer<ffi.Void>, ffi.Uint32)>>('CC_SHA224_Update');
  late final _CC_SHA224_Update = _CC_SHA224_UpdatePtr.asFunction<
      int Function(
          ffi.Pointer<CC_SHA256state_st>, ffi.Pointer<ffi.Void>, int)>();

  int CC_SHA224_Final(
    ffi.Pointer<ffi.UnsignedChar> md,
    ffi.Pointer<CC_SHA256state_st> c,
  ) {
    return _CC_SHA224_Final(
      md,
      c,
    );
  }

  late final _CC_SHA224_FinalPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.UnsignedChar>,
              ffi.Pointer<CC_SHA256state_st>)>>('CC_SHA224_Final');
  late final _CC_SHA224_Final = _CC_SHA224_FinalPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.UnsignedChar>, ffi.Pointer<CC_SHA256state_st>)>();

  ffi.Pointer<ffi.UnsignedChar> CC_SHA224(
    ffi.Pointer<ffi.Void> data,
    int len,
    ffi.Pointer<ffi.UnsignedChar> md,
  ) {
    return _CC_SHA224(
      data,
      len,
      md,
    );
  }

  late final _CC_SHA224Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.UnsignedChar> Function(ffi.Pointer<ffi.Void>,
              ffi.Uint32, ffi.Pointer<ffi.UnsignedChar>)>>('CC_SHA224');
  late final _CC_SHA224 = _CC_SHA224Ptr.asFunction<
      ffi.Pointer<ffi.UnsignedChar> Function(
          ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.UnsignedChar>)>();

  int CC_SHA256_Init(
    ffi.Pointer<CC_SHA256state_st> c,
  ) {
    return _CC_SHA256_Init(
      c,
    );
  }

  late final _CC_SHA256_InitPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<CC_SHA256state_st>)>>(
      'CC_SHA256_Init');
  late final _CC_SHA256_Init = _CC_SHA256_InitPtr.asFunction<
      int Function(ffi.Pointer<CC_SHA256state_st>)>();

  int CC_SHA256_Update(
    ffi.Pointer<CC_SHA256state_st> c,
    ffi.Pointer<ffi.Void> data,
    int len,
  ) {
    return _CC_SHA256_Update(
      c,
      data,
      len,
    );
  }

  late final _CC_SHA256_UpdatePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<CC_SHA256state_st>,
              ffi.Pointer<ffi.Void>, ffi.Uint32)>>('CC_SHA256_Update');
  late final _CC_SHA256_Update = _CC_SHA256_UpdatePtr.asFunction<
      int Function(
          ffi.Pointer<CC_SHA256state_st>, ffi.Pointer<ffi.Void>, int)>();

  int CC_SHA256_Final(
    ffi.Pointer<ffi.UnsignedChar> md,
    ffi.Pointer<CC_SHA256state_st> c,
  ) {
    return _CC_SHA256_Final(
      md,
      c,
    );
  }

  late final _CC_SHA256_FinalPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.UnsignedChar>,
              ffi.Pointer<CC_SHA256state_st>)>>('CC_SHA256_Final');
  late final _CC_SHA256_Final = _CC_SHA256_FinalPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.UnsignedChar>, ffi.Pointer<CC_SHA256state_st>)>();

  ffi.Pointer<ffi.UnsignedChar> CC_SHA256(
    ffi.Pointer<ffi.Void> data,
    int len,
    ffi.Pointer<ffi.UnsignedChar> md,
  ) {
    return _CC_SHA256(
      data,
      len,
      md,
    );
  }

  late final _CC_SHA256Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.UnsignedChar> Function(ffi.Pointer<ffi.Void>,
              ffi.Uint32, ffi.Pointer<ffi.UnsignedChar>)>>('CC_SHA256');
  late final _CC_SHA256 = _CC_SHA256Ptr.asFunction<
      ffi.Pointer<ffi.UnsignedChar> Function(
          ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.UnsignedChar>)>();

  int CC_SHA384_Init(
    ffi.Pointer<CC_SHA512state_st> c,
  ) {
    return _CC_SHA384_Init(
      c,
    );
  }

  late final _CC_SHA384_InitPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<CC_SHA512state_st>)>>(
      'CC_SHA384_Init');
  late final _CC_SHA384_Init = _CC_SHA384_InitPtr.asFunction<
      int Function(ffi.Pointer<CC_SHA512state_st>)>();

  int CC_SHA384_Update(
    ffi.Pointer<CC_SHA512state_st> c,
    ffi.Pointer<ffi.Void> data,
    int len,
  ) {
    return _CC_SHA384_Update(
      c,
      data,
      len,
    );
  }

  late final _CC_SHA384_UpdatePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<CC_SHA512state_st>,
              ffi.Pointer<ffi.Void>, ffi.Uint32)>>('CC_SHA384_Update');
  late final _CC_SHA384_Update = _CC_SHA384_UpdatePtr.asFunction<
      int Function(
          ffi.Pointer<CC_SHA512state_st>, ffi.Pointer<ffi.Void>, int)>();

  int CC_SHA384_Final(
    ffi.Pointer<ffi.UnsignedChar> md,
    ffi.Pointer<CC_SHA512state_st> c,
  ) {
    return _CC_SHA384_Final(
      md,
      c,
    );
  }

  late final _CC_SHA384_FinalPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.UnsignedChar>,
              ffi.Pointer<CC_SHA512state_st>)>>('CC_SHA384_Final');
  late final _CC_SHA384_Final = _CC_SHA384_FinalPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.UnsignedChar>, ffi.Pointer<CC_SHA512state_st>)>();

  ffi.Pointer<ffi.UnsignedChar> CC_SHA384(
    ffi.Pointer<ffi.Void> data,
    int len,
    ffi.Pointer<ffi.UnsignedChar> md,
  ) {
    return _CC_SHA384(
      data,
      len,
      md,
    );
  }

  late final _CC_SHA384Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.UnsignedChar> Function(ffi.Pointer<ffi.Void>,
              ffi.Uint32, ffi.Pointer<ffi.UnsignedChar>)>>('CC_SHA384');
  late final _CC_SHA384 = _CC_SHA384Ptr.asFunction<
      ffi.Pointer<ffi.UnsignedChar> Function(
          ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.UnsignedChar>)>();

  int CC_SHA512_Init(
    ffi.Pointer<CC_SHA512state_st> c,
  ) {
    return _CC_SHA512_Init(
      c,
    );
  }

  late final _CC_SHA512_InitPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<CC_SHA512state_st>)>>(
      'CC_SHA512_Init');
  late final _CC_SHA512_Init = _CC_SHA512_InitPtr.asFunction<
      int Function(ffi.Pointer<CC_SHA512state_st>)>();

  int CC_SHA512_Update(
    ffi.Pointer<CC_SHA512state_st> c,
    ffi.Pointer<ffi.Void> data,
    int len,
  ) {
    return _CC_SHA512_Update(
      c,
      data,
      len,
    );
  }

  late final _CC_SHA512_UpdatePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<CC_SHA512state_st>,
              ffi.Pointer<ffi.Void>, ffi.Uint32)>>('CC_SHA512_Update');
  late final _CC_SHA512_Update = _CC_SHA512_UpdatePtr.asFunction<
      int Function(
          ffi.Pointer<CC_SHA512state_st>, ffi.Pointer<ffi.Void>, int)>();

  int CC_SHA512_Final(
    ffi.Pointer<ffi.UnsignedChar> md,
    ffi.Pointer<CC_SHA512state_st> c,
  ) {
    return _CC_SHA512_Final(
      md,
      c,
    );
  }

  late final _CC_SHA512_FinalPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.UnsignedChar>,
              ffi.Pointer<CC_SHA512state_st>)>>('CC_SHA512_Final');
  late final _CC_SHA512_Final = _CC_SHA512_FinalPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.UnsignedChar>, ffi.Pointer<CC_SHA512state_st>)>();

  ffi.Pointer<ffi.UnsignedChar> CC_SHA512(
    ffi.Pointer<ffi.Void> data,
    int len,
    ffi.Pointer<ffi.UnsignedChar> md,
  ) {
    return _CC_SHA512(
      data,
      len,
      md,
    );
  }

  late final _CC_SHA512Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.UnsignedChar> Function(ffi.Pointer<ffi.Void>,
              ffi.Uint32, ffi.Pointer<ffi.UnsignedChar>)>>('CC_SHA512');
  late final _CC_SHA512 = _CC_SHA512Ptr.asFunction<
      ffi.Pointer<ffi.UnsignedChar> Function(
          ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.UnsignedChar>)>();

  /// !
  /// @function   CCHmacInit
  /// @abstract   Initialize an CCHmacContext with provided raw key bytes.
  ///
  /// @param      ctx         An HMAC context.
  /// @param      algorithm   HMAC algorithm to perform.
  /// @param      key         Raw key bytes.
  /// @param      keyLength   Length of raw key bytes; can be any
  /// length including zero.
  void CCHmacInit(
    ffi.Pointer<CCHmacContext> ctx,
    int algorithm,
    ffi.Pointer<ffi.Void> key,
    int keyLength,
  ) {
    return _CCHmacInit(
      ctx,
      algorithm,
      key,
      keyLength,
    );
  }

  late final _CCHmacInitPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<CCHmacContext>, ffi.Uint32,
              ffi.Pointer<ffi.Void>, ffi.Size)>>('CCHmacInit');
  late final _CCHmacInit = _CCHmacInitPtr.asFunction<
      void Function(
          ffi.Pointer<CCHmacContext>, int, ffi.Pointer<ffi.Void>, int)>();

  /// !
  /// @function   CCHmacUpdate
  /// @abstract   Process some data.
  ///
  /// @param      ctx         An HMAC context.
  /// @param      data        Data to process.
  /// @param      dataLength  Length of data to process, in bytes.
  ///
  /// @discussion This can be called multiple times.
  void CCHmacUpdate(
    ffi.Pointer<CCHmacContext> ctx,
    ffi.Pointer<ffi.Void> data,
    int dataLength,
  ) {
    return _CCHmacUpdate(
      ctx,
      data,
      dataLength,
    );
  }

  late final _CCHmacUpdatePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<CCHmacContext>, ffi.Pointer<ffi.Void>,
              ffi.Size)>>('CCHmacUpdate');
  late final _CCHmacUpdate = _CCHmacUpdatePtr.asFunction<
      void Function(ffi.Pointer<CCHmacContext>, ffi.Pointer<ffi.Void>, int)>();

  /// !
  /// @function   CCHmacFinal
  /// @abstract   Obtain the final Message Authentication Code.
  ///
  /// @param      ctx         An HMAC context.
  /// @param      macOut      Destination of MAC; allocated by caller.
  ///
  /// @discussion The length of the MAC written to *macOut is the same as
  /// the digest length associated with the HMAC algorithm:
  ///
  /// kCCHmacAlgSHA1 : CC_SHA1_DIGEST_LENGTH
  /// kCCHmacAlgSHA256  : CC_SHA256_DIGEST_LENGTH
  ///
  /// The MAC must be verified by comparing the computed and expected values
  /// using timingsafe_bcmp. Other comparison functions (e.g. memcmp)
  /// must not be used as they may be vulnerable to practical timing attacks,
  /// leading to MAC forgery.
  void CCHmacFinal(
    ffi.Pointer<CCHmacContext> ctx,
    ffi.Pointer<ffi.Void> macOut,
  ) {
    return _CCHmacFinal(
      ctx,
      macOut,
    );
  }

  late final _CCHmacFinalPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<CCHmacContext>,
              ffi.Pointer<ffi.Void>)>>('CCHmacFinal');
  late final _CCHmacFinal = _CCHmacFinalPtr.asFunction<
      void Function(ffi.Pointer<CCHmacContext>, ffi.Pointer<ffi.Void>)>();

  /// !
  /// @function   CCHmac
  /// @abstract   Stateless, one-shot HMAC function
  ///
  /// @param      algorithm   HMAC algorithm to perform.
  /// @param      key         Raw key bytes.
  /// @param      keyLength   Length of raw key bytes; can be any
  /// length including zero.
  /// @param      data        Data to process.
  /// @param      dataLength  Length of data to process, in bytes.
  /// @param      macOut      Destination of MAC; allocated by caller.
  ///
  /// @discussion The length of the MAC written to *macOut is the same as the digest length associated with the HMAC algorithm:
  /// kCCHmacAlgSHA1 : CC_SHA1_DIGEST_LENGTH
  /// kCCHmacAlgSHA256  : CC_SHA256_DIGEST_LENGTH
  ///
  /// The MAC must be verified by comparing the computed and expected values
  /// using timingsafe_bcmp. Other comparison functions (e.g. memcmp)
  /// must not be used as they may be vulnerable to practical timing attacks,
  /// leading to MAC forgery.
  void CCHmac(
    int algorithm,
    ffi.Pointer<ffi.Void> key,
    int keyLength,
    ffi.Pointer<ffi.Void> data,
    int dataLength,
    ffi.Pointer<ffi.Void> macOut,
  ) {
    return _CCHmac(
      algorithm,
      key,
      keyLength,
      data,
      dataLength,
      macOut,
    );
  }

  late final _CCHmacPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Uint32,
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              ffi.Pointer<ffi.Void>)>>('CCHmac');
  late final _CCHmac = _CCHmacPtr.asFunction<
      void Function(int, ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>, int,
          ffi.Pointer<ffi.Void>)>();

  /// @function  CCKeyDerivationPBKDF
  /// @abstract  Derive a key from a text password/passphrase
  ///
  /// @param algorithm       Currently only PBKDF2 is available via kCCPBKDF2
  /// @param password        The text password used as input to the derivation
  /// function.  The actual octets present in this string
  /// will be used with no additional processing.  It's
  /// extremely important that the same encoding and
  /// normalization be used each time this routine is
  /// called if the same key is  expected to be derived.
  /// @param passwordLen     The length of the text password in bytes.
  /// @param salt            The salt byte values used as input to the derivation
  /// function. The pointer can be NULL, only when saltLen is zero.
  /// @param saltLen         The length of the salt in bytes. It can be zero.
  /// @param prf             The Pseudo Random Algorithm to use for the derivation
  /// iterations.
  /// @param rounds          The number of rounds of the Pseudo Random Algorithm
  /// to use. It cannot be zero.
  /// @param derivedKey      The resulting derived key produced by the function.
  /// The space for this must be provided by the caller.
  /// @param derivedKeyLen   The expected length of the derived key in bytes. It cannot be zero.
  ///
  /// @discussion The following values are used to designate the PRF:
  ///
  /// kCCPRFHmacAlgSHA1
  /// kCCPRFHmacAlgSHA224
  /// kCCPRFHmacAlgSHA256
  /// kCCPRFHmacAlgSHA384
  /// kCCPRFHmacAlgSHA512
  ///
  /// @result     kCCParamError can result from bad values for the password, salt,
  /// and unwrapped key pointers as well as a bad value for the prf
  /// function.
  int CCKeyDerivationPBKDF(
    int algorithm,
    ffi.Pointer<ffi.Char> password,
    int passwordLen,
    ffi.Pointer<ffi.Uint8> salt,
    int saltLen,
    int prf,
    int rounds,
    ffi.Pointer<ffi.Uint8> derivedKey,
    int derivedKeyLen,
  ) {
    return _CCKeyDerivationPBKDF(
      algorithm,
      password,
      passwordLen,
      salt,
      saltLen,
      prf,
      rounds,
      derivedKey,
      derivedKeyLen,
    );
  }

  late final _CCKeyDerivationPBKDFPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Uint32,
              ffi.Pointer<ffi.Char>,
              ffi.Size,
              ffi.Pointer<ffi.Uint8>,
              ffi.Size,
              ffi.Uint32,
              ffi.UnsignedInt,
              ffi.Pointer<ffi.Uint8>,
              ffi.Size)>>('CCKeyDerivationPBKDF');
  late final _CCKeyDerivationPBKDF = _CCKeyDerivationPBKDFPtr.asFunction<
      int Function(int, ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Uint8>, int,
          int, int, ffi.Pointer<ffi.Uint8>, int)>();

  /// @function  CCCalibratePBKDF
  /// @abstract  Determine the number of PRF rounds to use for a specific delay on
  /// the current platform.
  /// @param algorithm       Currently only PBKDF2 is available via kCCPBKDF2
  /// @param passwordLen     The length of the text password in bytes.
  /// @param saltLen         The length of the salt in bytes. saltlen must be smaller than 133.
  /// @param prf             The Pseudo Random Algorithm to use for the derivation
  /// iterations.
  /// @param derivedKeyLen   The expected length of the derived key in bytes.
  /// @param msec            The targetted duration we want to achieve for a key
  /// derivation with these parameters.
  ///
  /// @result the number of iterations to use for the desired processing time.
  /// Returns a minimum of 10000 iterations (safety net, not a particularly recommended value)
  /// The number of iterations is a trade-off of usability and security. If there is an error
  /// the function returns (unsigned)(-1). The minimum return value is set to 10000.
  int CCCalibratePBKDF(
    int algorithm,
    int passwordLen,
    int saltLen,
    int prf,
    int derivedKeyLen,
    int msec,
  ) {
    return _CCCalibratePBKDF(
      algorithm,
      passwordLen,
      saltLen,
      prf,
      derivedKeyLen,
      msec,
    );
  }

  late final _CCCalibratePBKDFPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(ffi.Uint32, ffi.Size, ffi.Size, ffi.Uint32,
              ffi.Size, ffi.Uint32)>>('CCCalibratePBKDF');
  late final _CCCalibratePBKDF = _CCCalibratePBKDFPtr.asFunction<
      int Function(int, int, int, int, int, int)>();

  /// !
  /// @function  CCSymmetricKeyWrap
  /// @abstract  Wrap a symmetric key with a Key Encryption Key (KEK).
  ///
  /// @param algorithm       Currently only AES Keywrapping (rfc3394) is available
  /// via kCCWRAPAES
  /// @param iv              The initialization value to be used.  CCrfc3394_iv is
  /// available as a constant for the standard IV to use.
  /// @param ivLen           The length of the initialization value to be used.
  /// CCrfc3394_ivLen is available as a constant for the
  /// standard IV to use.
  /// @param kek             The Key Encryption Key to be used to wrap the raw key.
  /// @param kekLen          The length of the KEK in bytes.
  /// @param rawKey          The raw key bytes to be wrapped.
  /// @param rawKeyLen       The length of the key in bytes.
  /// @param wrappedKey      The resulting wrapped key produced by the function.
  /// The space for this must be provided by the caller.
  /// @param wrappedKeyLen   The length of the wrapped key in bytes.
  ///
  /// @discussion The algorithm chosen is determined by the algorithm parameter
  /// and the size of the key being wrapped (ie aes128 for 128 bit
  /// keys).
  ///
  /// @result    kCCBufferTooSmall indicates insufficent space in the wrappedKey
  /// buffer.
  /// kCCParamError can result from bad values for the kek, rawKey, and
  /// wrappedKey key pointers.
  int CCSymmetricKeyWrap(
    int algorithm,
    ffi.Pointer<ffi.Uint8> iv,
    int ivLen,
    ffi.Pointer<ffi.Uint8> kek,
    int kekLen,
    ffi.Pointer<ffi.Uint8> rawKey,
    int rawKeyLen,
    ffi.Pointer<ffi.Uint8> wrappedKey,
    ffi.Pointer<ffi.Size> wrappedKeyLen,
  ) {
    return _CCSymmetricKeyWrap(
      algorithm,
      iv,
      ivLen,
      kek,
      kekLen,
      rawKey,
      rawKeyLen,
      wrappedKey,
      wrappedKeyLen,
    );
  }

  late final _CCSymmetricKeyWrapPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Uint32,
              ffi.Pointer<ffi.Uint8>,
              ffi.Size,
              ffi.Pointer<ffi.Uint8>,
              ffi.Size,
              ffi.Pointer<ffi.Uint8>,
              ffi.Size,
              ffi.Pointer<ffi.Uint8>,
              ffi.Pointer<ffi.Size>)>>('CCSymmetricKeyWrap');
  late final _CCSymmetricKeyWrap = _CCSymmetricKeyWrapPtr.asFunction<
      int Function(
          int,
          ffi.Pointer<ffi.Uint8>,
          int,
          ffi.Pointer<ffi.Uint8>,
          int,
          ffi.Pointer<ffi.Uint8>,
          int,
          ffi.Pointer<ffi.Uint8>,
          ffi.Pointer<ffi.Size>)>();

  /// !
  /// @function  CCSymmetricKeyUnwrap
  /// @abstract  Unwrap a symmetric key with a Key Encryption Key (KEK).
  ///
  /// @param algorithm       Currently only AES Keywrapping (rfc3394) is available
  /// via kCCWRAPAES
  /// @param iv              The initialization value to be used.  CCrfc3394_iv is
  /// available as a constant for the standard IV to use.
  /// @param ivLen           The length of the initialization value to be used.
  /// CCrfc3394_ivLen is available as a constant for the
  /// standard IV to use.
  /// @param kek             The Key Encryption Key to be used to unwrap the raw key.
  /// @param kekLen          The length of the KEK in bytes.
  /// @param wrappedKey      The wrapped key bytes.
  /// @param wrappedKeyLen   The length of the wrapped key in bytes.
  /// @param rawKey          The resulting raw key bytes. The space for this must
  /// be provided by the caller.
  /// @param rawKeyLen       The length of the raw key in bytes.
  ///
  /// @discussion The algorithm chosen is determined by the algorithm parameter
  /// and the size of the key being wrapped (ie aes128 for 128 bit
  /// keys).
  ///
  /// @result    kCCBufferTooSmall indicates insufficent space in the rawKey buffer.
  /// kCCParamError can result from bad values for the kek, rawKey, and
  /// wrappedKey key pointers.
  int CCSymmetricKeyUnwrap(
    int algorithm,
    ffi.Pointer<ffi.Uint8> iv,
    int ivLen,
    ffi.Pointer<ffi.Uint8> kek,
    int kekLen,
    ffi.Pointer<ffi.Uint8> wrappedKey,
    int wrappedKeyLen,
    ffi.Pointer<ffi.Uint8> rawKey,
    ffi.Pointer<ffi.Size> rawKeyLen,
  ) {
    return _CCSymmetricKeyUnwrap(
      algorithm,
      iv,
      ivLen,
      kek,
      kekLen,
      wrappedKey,
      wrappedKeyLen,
      rawKey,
      rawKeyLen,
    );
  }

  late final _CCSymmetricKeyUnwrapPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Uint32,
              ffi.Pointer<ffi.Uint8>,
              ffi.Size,
              ffi.Pointer<ffi.Uint8>,
              ffi.Size,
              ffi.Pointer<ffi.Uint8>,
              ffi.Size,
              ffi.Pointer<ffi.Uint8>,
              ffi.Pointer<ffi.Size>)>>('CCSymmetricKeyUnwrap');
  late final _CCSymmetricKeyUnwrap = _CCSymmetricKeyUnwrapPtr.asFunction<
      int Function(
          int,
          ffi.Pointer<ffi.Uint8>,
          int,
          ffi.Pointer<ffi.Uint8>,
          int,
          ffi.Pointer<ffi.Uint8>,
          int,
          ffi.Pointer<ffi.Uint8>,
          ffi.Pointer<ffi.Size>)>();

  /// !
  /// @function  CCSymmetricWrappedSize
  /// @abstract  Determine the buffer size required to hold a key wrapped with
  /// CCAESKeyWrap().
  ///
  /// @param     algorithm       Currently only AES Keywrapping (rfc3394) is
  /// available via kCCWRAPAES
  /// @param     rawKeyLen       The length of the key in bytes.
  /// @result    The length of the resulting wrapped key.
  int CCSymmetricWrappedSize(
    int algorithm,
    int rawKeyLen,
  ) {
    return _CCSymmetricWrappedSize(
      algorithm,
      rawKeyLen,
    );
  }

  late final _CCSymmetricWrappedSizePtr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Uint32, ffi.Size)>>(
          'CCSymmetricWrappedSize');
  late final _CCSymmetricWrappedSize =
      _CCSymmetricWrappedSizePtr.asFunction<int Function(int, int)>();

  /// !
  /// @function  CCSymmetricUnwrappedSize
  /// @abstract  Determine the buffer size required to hold a key unwrapped with
  /// CCAESKeyUnwrap().
  ///
  /// @param     algorithm       Currently only AES Keywrapping (rfc3394) is
  /// available via kCCWRAPAES
  /// @param     wrappedKeyLen   The length of the wrapped key in bytes.
  /// @result    The length of the resulting raw key.
  int CCSymmetricUnwrappedSize(
    int algorithm,
    int wrappedKeyLen,
  ) {
    return _CCSymmetricUnwrappedSize(
      algorithm,
      wrappedKeyLen,
    );
  }

  late final _CCSymmetricUnwrappedSizePtr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Uint32, ffi.Size)>>(
          'CCSymmetricUnwrappedSize');
  late final _CCSymmetricUnwrappedSize =
      _CCSymmetricUnwrappedSizePtr.asFunction<int Function(int, int)>();
}

final class CCCryptor extends ffi.Opaque {}

final class CC_MD2state_st extends ffi.Struct {
  @ffi.Int()
  external int num;

  @ffi.Array.multi([16])
  external ffi.Array<ffi.UnsignedChar> data;

  @ffi.Array.multi([16])
  external ffi.Array<ffi.Uint32> cksm;

  @ffi.Array.multi([16])
  external ffi.Array<ffi.Uint32> state;
}

final class CC_MD4state_st extends ffi.Struct {
  @ffi.Uint32()
  external int A;

  @ffi.Uint32()
  external int B;

  @ffi.Uint32()
  external int C;

  @ffi.Uint32()
  external int D;

  @ffi.Uint32()
  external int Nl;

  @ffi.Uint32()
  external int Nh;

  @ffi.Array.multi([16])
  external ffi.Array<ffi.Uint32> data;

  @ffi.Uint32()
  external int num;
}

final class CC_MD5state_st extends ffi.Struct {
  @ffi.Uint32()
  external int A;

  @ffi.Uint32()
  external int B;

  @ffi.Uint32()
  external int C;

  @ffi.Uint32()
  external int D;

  @ffi.Uint32()
  external int Nl;

  @ffi.Uint32()
  external int Nh;

  @ffi.Array.multi([16])
  external ffi.Array<ffi.Uint32> data;

  @ffi.Int()
  external int num;
}

final class CC_SHA1state_st extends ffi.Struct {
  @ffi.Uint32()
  external int h0;

  @ffi.Uint32()
  external int h1;

  @ffi.Uint32()
  external int h2;

  @ffi.Uint32()
  external int h3;

  @ffi.Uint32()
  external int h4;

  @ffi.Uint32()
  external int Nl;

  @ffi.Uint32()
  external int Nh;

  @ffi.Array.multi([16])
  external ffi.Array<ffi.Uint32> data;

  @ffi.Int()
  external int num;
}

/// same context struct is used for SHA224 and SHA256
final class CC_SHA256state_st extends ffi.Struct {
  @ffi.Array.multi([2])
  external ffi.Array<ffi.Uint32> count;

  @ffi.Array.multi([8])
  external ffi.Array<ffi.Uint32> hash;

  @ffi.Array.multi([16])
  external ffi.Array<ffi.Uint32> wbuf;
}

/// same context struct is used for SHA384 and SHA512
final class CC_SHA512state_st extends ffi.Struct {
  @ffi.Array.multi([2])
  external ffi.Array<ffi.Uint64> count;

  @ffi.Array.multi([8])
  external ffi.Array<ffi.Uint64> hash;

  @ffi.Array.multi([16])
  external ffi.Array<ffi.Uint64> wbuf;
}

final class CCHmacContext extends ffi.Struct {
  @ffi.Array.multi([96])
  external ffi.Array<ffi.Uint32> ctx;
}

const int kCCSuccess = 0;

const int kCCParamError = -4300;

const int kCCBufferTooSmall = -4301;

const int kCCMemoryFailure = -4302;

const int kCCAlignmentError = -4303;

const int kCCDecodeError = -4304;

const int kCCUnimplemented = -4305;

const int kCCOverflow = -4306;

const int kCCRNGFailure = -4307;

const int kCCUnspecifiedError = -4308;

const int kCCCallSequenceError = -4309;

const int kCCKeySizeError = -4310;

const int kCCInvalidKey = -4311;

const int kCCEncrypt = 0;

const int kCCDecrypt = 1;

const int kCCAlgorithmAES128 = 0;

const int kCCAlgorithmAES = 0;

const int kCCAlgorithmDES = 1;

const int kCCAlgorithm3DES = 2;

const int kCCAlgorithmCAST = 3;

const int kCCAlgorithmRC4 = 4;

const int kCCAlgorithmRC2 = 5;

const int kCCAlgorithmBlowfish = 6;

const int kCCOptionPKCS7Padding = 1;

const int kCCOptionECBMode = 2;

const int kCCKeySizeAES128 = 16;

const int kCCKeySizeAES192 = 24;

const int kCCKeySizeAES256 = 32;

const int kCCKeySizeDES = 8;

const int kCCKeySize3DES = 24;

const int kCCKeySizeMinCAST = 5;

const int kCCKeySizeMaxCAST = 16;

const int kCCKeySizeMinRC4 = 1;

const int kCCKeySizeMaxRC4 = 512;

const int kCCKeySizeMinRC2 = 1;

const int kCCKeySizeMaxRC2 = 128;

const int kCCKeySizeMinBlowfish = 8;

const int kCCKeySizeMaxBlowfish = 56;

const int kCCBlockSizeAES128 = 16;

const int kCCBlockSizeDES = 8;

const int kCCBlockSize3DES = 8;

const int kCCBlockSizeCAST = 8;

const int kCCBlockSizeRC2 = 8;

const int kCCBlockSizeBlowfish = 8;

const int kCCContextSizeAES128 = 404;

const int kCCContextSizeDES = 240;

const int kCCContextSize3DES = 496;

const int kCCContextSizeCAST = 240;

const int kCCContextSizeRC4 = 1072;

const int kCCModeECB = 1;

const int kCCModeCBC = 2;

const int kCCModeCFB = 3;

const int kCCModeCTR = 4;

const int kCCModeOFB = 7;

const int kCCModeRC4 = 9;

const int kCCModeCFB8 = 10;

const int kCCModeOptionCTR_BE = 2;

const int kCCHmacAlgSHA1 = 0;

const int kCCHmacAlgMD5 = 1;

const int kCCHmacAlgSHA256 = 2;

const int kCCHmacAlgSHA384 = 3;

const int kCCHmacAlgSHA512 = 4;

const int kCCHmacAlgSHA224 = 5;

const int kCCPBKDF2 = 2;

const int kCCPRFHmacAlgSHA1 = 1;

const int kCCPRFHmacAlgSHA224 = 2;

const int kCCPRFHmacAlgSHA256 = 3;

const int kCCPRFHmacAlgSHA384 = 4;

const int kCCPRFHmacAlgSHA512 = 5;

const int kCCWRAPAES = 1;
